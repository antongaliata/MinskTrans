[{"C:\\Users\\Anton\\Desktop\\MinskTrans\\googleMap\\src\\index.tsx":"1","C:\\Users\\Anton\\Desktop\\MinskTrans\\googleMap\\src\\reportWebVitals.ts":"2","C:\\Users\\Anton\\Desktop\\MinskTrans\\googleMap\\src\\Map.tsx":"3","C:\\Users\\Anton\\Desktop\\MinskTrans\\googleMap\\src\\state.ts":"4","C:\\Users\\Anton\\Desktop\\MinskTrans\\googleMap\\src\\Route.tsx":"5","C:\\Users\\Anton\\Desktop\\MinskTrans\\googleMap\\src\\times.ts":"6","C:\\Users\\Anton\\Desktop\\MinskTrans\\googleMap\\src\\InformationTable.tsx":"7","C:\\Users\\Anton\\Desktop\\MinskTrans\\googleMap\\src\\Timetable.tsx":"8","C:\\Users\\Anton\\Desktop\\MinskTrans\\googleMap\\src\\SelectedStop.tsx":"9"},{"size":494,"mtime":1612451141069,"results":"10","hashOfConfig":"11"},{"size":425,"mtime":1612360235329,"results":"12","hashOfConfig":"11"},{"size":1170,"mtime":1612897081013,"results":"13","hashOfConfig":"11"},{"size":20616,"mtime":1616154293113,"results":"14","hashOfConfig":"11"},{"size":1839,"mtime":1613660291254,"results":"15","hashOfConfig":"11"},{"size":5948,"mtime":1612723906627,"results":"16","hashOfConfig":"11"},{"size":2024,"mtime":1613659645768,"results":"17","hashOfConfig":"11"},{"size":2083,"mtime":1615486166394,"results":"18","hashOfConfig":"11"},{"size":1273,"mtime":1612995986146,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"vepbq8",{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"29","usedDeprecatedRules":"22"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"35","usedDeprecatedRules":"22"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40","usedDeprecatedRules":"22"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"C:\\Users\\Anton\\Desktop\\MinskTrans\\googleMap\\src\\index.tsx",[],["43","44"],"C:\\Users\\Anton\\Desktop\\MinskTrans\\googleMap\\src\\reportWebVitals.ts",[],"C:\\Users\\Anton\\Desktop\\MinskTrans\\googleMap\\src\\Map.tsx",[],"C:\\Users\\Anton\\Desktop\\MinskTrans\\googleMap\\src\\state.ts",["45","46","47","48","49","50","51","52","53","54","55","56","57","58","59"],"import {Loader} from \"@googlemaps/js-api-loader\";\nimport MarkerClusterer from \"@googlemaps/markerclustererplus\";\nimport {locationsType, stoppingType} from \"./Map\";\nimport {routesType} from \"./Route\";\nimport getTimes, {timetableType, trips_by_daysType} from './times'\nimport {tableType} from \"./InformationTable\";\n\n\nexport const promiseDataMinskTransStops = apiRequestHandler('http://www.minsktrans.by/city/minsk/stops.txt')\nexport const promiseDataMinskTransRoutes = apiRequestHandler('http://www.minsktrans.by/city/minsk/routes.txt')\nexport const promiseDataMinskTransTimes = apiRequestHandlerTimes('http://www.minsktrans.by/city/minsk/times.txt').then((data) => getTimes(data))\n\nasync function apiRequestHandlerTimes(link: string) {\n    const request = await fetch(`https://api.allorigins.win/get?url=${link}`)\n    const text = (await request.json()).contents.trim()\n    return text.trim().split('\\n')\n}\n\nasync function apiRequestHandler(link: string) {\n    const request = await fetch(`https://api.allorigins.win/get?url=${link}`)\n    const text = (await request.json()).contents.trim().split('\\n')\n    const keys = text.shift().split(';')\n    return text.map((t: string) => {\n        return Object.fromEntries(t.split(';')\n            .map((value, index) => [keys[index], value]))\n    })\n}\n\n\nexport class TimetableRoute {\n    idRoute: string\n    trips_by_days: Array<trips_by_daysType>\n    nameRoute: string\n    stops_by_route: Array<stoppingType>\n\n    constructor(idRoute: string, trips_by_days: Array<trips_by_daysType>, nameRoute: string, stops_by_route: Array<stoppingType>) {\n        this.idRoute = idRoute\n        this.nameRoute = nameRoute\n        this.trips_by_days = trips_by_days\n        this.stops_by_route = stops_by_route\n    }\n}\n\n\n\nexport const handlerMarkers = (objStopping: stoppingType): locationsType => {\n    const handlerLatLng = (LatLng: string) => {\n        const result = LatLng.split('')\n        result.splice(2, 0, '.')\n        return result.join('')\n    }\n    return {\n        lat: Number(handlerLatLng(objStopping.Lat)),\n        lng: Number(handlerLatLng(objStopping.Lng))\n    }\n}\n\nlet directionsService: google.maps.DirectionsService\nlet directionsRenderer: google.maps.DirectionsRenderer\nlet map: google.maps.Map\n\nconst arrayDirectionsRenderer_for_calcRoute: Array<google.maps.DirectionsRenderer> = []\nconst arrayDirectionsRenderer_for_calcRouteClick: Array<google.maps.DirectionsRenderer> = []\nconst arrayDirectionsRenderer_for_calcRouteClick2: Array<google.maps.DirectionsRenderer> = []\nconst arrayDirectionsRenderer_for_walking_route: Array<google.maps.DirectionsRenderer> = []\nconst render_route_walking: Array<{ pointStart: locationsType, pointEnd: locationsType }> = []\n\nconst markersClick: Array<google.maps.Marker> = []\nlet distance_from_a_to_b: number\n\nlet dataRoute: Array<routesType>\nexport const callbackDataRoute = (dataRoutes: Array<routesType>) => {\n    dataRoute = dataRoutes\n}\n\nconst handlerWindowInfo = (dataStopping: Array<stoppingType>, location: google.maps.LatLngLiteral | undefined) => {\n\n    const locationsClick: stoppingType | undefined = dataStopping.find((objStopping: stoppingType) => handlerMarkers(objStopping).lng === location?.lng && handlerMarkers(objStopping).lat === location.lat)\n\n    const passingRoutes = dataRoute.filter((objRoute: routesType) => objRoute.RouteStops.split(',').find((stop) => locationsClick?.ID.toString() === stop))\n\n    return (\n        '<div>' + (locationsClick?.Name === '' ? '<h1>' + 'Остановка' + '</h1>' : '<h1>' + locationsClick?.Name) + '</h1>' + '</div>' +\n        '<h4>' + 'Проходящие маршруты:' + '</h4>' + '</br>' +\n        passingRoutes.map((t) => t.RouteName + '</br>')\n    )\n}\n\n\nexport function initMap(locations: Array<locationsType>, dataStopping: Array<stoppingType>) {\n\n    const loader = new Loader({\n        apiKey: \"AIzaSyC_B7FYGdGaaosiiHqVjXsn4JBvAvKDZpg\",\n        version: \"weekly\",\n        libraries: [\"geometry\"]\n    });\n    loader.load().then(() => {\n        map = new google.maps.Map(document.getElementById(\"map\") as HTMLElement, {\n            center: {lat: 53.902214, lng: 27.561817},\n            zoom: 10\n        });\n\n        directionsService = new google.maps.DirectionsService()\n        directionsRenderer = new google.maps.DirectionsRenderer()\n        directionsRenderer.setMap(map)\n\n\n        map.addListener(\"click\", (e) => {\n            if (markersClick.length === 2) {\n                for (let i = 0; i < markersClick.length; i++) {\n                    markersClick[i].setMap(null)\n                }\n                markersClick.length = 0\n            }\n            placeMarkerAndPanTo(e.latLng, map)\n        });\n\n        function placeMarkerAndPanTo(latLng: google.maps.LatLng, map: google.maps.Map) {\n\n            start_and_end_point.push(latLng.toJSON())\n            if (start_and_end_point.length === 2) {\n\n                distance_from_a_to_b = google.maps.geometry.spherical.computeDistanceBetween(new google.maps.LatLng(start_and_end_point[0]), new google.maps.LatLng(start_and_end_point[1])) * 0.001\n\n                calcRouteClick(start_and_end_point[0], start_and_end_point[1], dataStopping, dataRoute)\n                start_and_end_point.length = 0\n            }\n            const marker = new google.maps.Marker({\n                position: latLng,\n                map: map,\n                animation: markersClick.length < 1 ? google.maps.Animation.BOUNCE : google.maps.Animation.DROP,\n                icon: {\n                    url: markersClick.length < 1 ? \"https://img.icons8.com/doodle/48/000000/standing-man.png\" : \"https://img.icons8.com/emoji/48/000000/cross-mark-emoji.png\",\n                    scaledSize: <google.maps.Size>{height: 35, width: 35}\n                }\n            });\n            map.panTo(latLng);\n            markersClick.push(marker)\n        }\n\n\n        const markers = locations.map((location: locationsType) => {\n            return new google.maps.Marker({\n                position: location,\n                icon: {\n                    url: \"https://img.icons8.com/dusk/48/000000/marker.png\",\n                    scaledSize: <google.maps.Size>{height: 35, width: 35}\n                }\n            })\n        });\n\n        markers.map((m) => {\n            m.addListener(\"click\", () => {\n                const infowindow = new google.maps.InfoWindow({\n                    content: handlerWindowInfo(dataStopping, m.getPosition()?.toJSON())\n                });\n                infowindow.open(map, m);\n            });\n        })\n        new MarkerClusterer(map, markers, {\n            imagePath:\n                \"https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m\",\n        });\n    })\n}\n\n\nexport function calcRoute(dataRoutes: Array<routesType>, dataStopping: Array<stoppingType>, timetable: Array<timetableType>, setTimetableRoute: (TimetableRoute: TimetableRoute) => void, setTable: (t: tableType) => void) {\n\n    setTable(null)\n    //cleaning routes\n    arrayDirectionsRenderer_for_calcRoute.forEach((directionsRenderer: google.maps.DirectionsRenderer) => {\n        directionsRenderer.setDirections({\n            geocoded_waypoints: [],\n            routes: []\n        })\n    });\n\n    const routeId = (document.getElementById('routes') as HTMLInputElement).value\n    const stoppingRoute = dataRoutes.filter((objRoute: routesType) => objRoute.RouteID === routeId)\n        [0].RouteStops.split(',')\n\n    const selectedTimetable = timetable.filter((objTimetable) => {\n        return objTimetable.routeID === Number(routeId)\n    })[0]\n\n    const routeName = dataRoutes.filter((objRoute: routesType) => objRoute.RouteID === routeId ? objRoute.RouteName : null)\n\n    const dataStopsForRoute: Array<stoppingType> = []\n    dataStopping.forEach((objStopping: stoppingType) => {\n        for (let i = 0; i < stoppingRoute.length; i++) {\n            if (objStopping.ID === stoppingRoute[i]) {\n                dataStopsForRoute.push(objStopping)\n            }\n        }\n    });\n\n    const timetableRoute = new TimetableRoute(routeId, selectedTimetable.trips_by_days, routeName[0].RouteName, dataStopsForRoute)\n    setTimetableRoute(timetableRoute)\n\n    const route: Array<locationsType> = route_building(dataStopping, stoppingRoute)\n\n    const markerOptions = {\n        suppressMarkers: false,\n        preserveViewport: false,\n        markerOptions: {\n            animation: google.maps.Animation.DROP,\n            icon: {\n                url: \"https://img.icons8.com/dusk/64/000000/bus2.png\",\n                scaledSize: <google.maps.Size>{height: 30, width: 30}\n            }\n        }\n    };\n\n    split_and_show_route(route, arrayDirectionsRenderer_for_calcRoute, markerOptions, true)\n\n}\n\n\nconst start_and_end_point: Array<google.maps.LatLngLiteral> = []\n\n\n// let arrayDirectionsRenderer: Array<Array<google.maps.DirectionsRenderer>> = []\n\n\nfunction calcRouteClick(start: locationsType, end: locationsType, dataStopping: Array<stoppingType>, dataRoute: Array<routesType>) {\n\n    const cleaning_routes = (arrayDirectionsRenderer: Array<google.maps.DirectionsRenderer>) => {\n\n        arrayDirectionsRenderer.forEach((directionsRenderer: google.maps.DirectionsRenderer) => {\n            directionsRenderer.setDirections({\n                geocoded_waypoints: [],\n                routes: []\n            })\n        })\n        render_route_walking.length = 0\n    }\n\n    cleaning_routes(arrayDirectionsRenderer_for_calcRouteClick)\n    cleaning_routes(arrayDirectionsRenderer_for_calcRouteClick2)\n    cleaning_routes(arrayDirectionsRenderer_for_walking_route)\n\n\n    type optimalRouteType = {\n        distance_to_end_point: number,\n        distance_to_start_point: number,\n        stop_to_exit: stoppingType,\n        start_stop: stoppingType,\n        route: routesType\n    }\n\n    const search_optimal_route = (start_point: locationsType, end_point: locationsType) => {\n\n        const arrayRouteStopsId: Array<string> = []\n        dataRoute.forEach((route) => {\n            const array = route.RouteStops.split(',')\n            arrayRouteStopsId.push(...array)\n        })\n\n        const stops_with_route = dataStopping.filter((stop) => {\n            if (arrayRouteStopsId.find((stopId) => stop.ID === stopId)) {\n                return stop\n            }\n        })\n\n        const distance_km_to_stops = stops_with_route.map((stop) => {\n            return {\n                distance_km_to_stop: google.maps.geometry.spherical.computeDistanceBetween(new google.maps.LatLng(start_point), new google.maps.LatLng(handlerMarkers(stop))) * 0.001,\n                stop: stop\n            }\n        })\n\n        let distance_limit_km_to_stops: Array<{ distance_km_to_stop: number, stop: stoppingType }> = []\n        let search_radius_km = 1\n\n        while (distance_limit_km_to_stops.length < 1) {\n            distance_limit_km_to_stops = distance_km_to_stops.filter((obj) => obj.distance_km_to_stop < search_radius_km && obj.distance_km_to_stop !== 0)\n            search_radius_km++\n        }\n\n\n        const passing_routes_from_start_stop: Array<{ route: routesType, stop_and_distance: { distance_km_to_stop: number, stop: stoppingType } }> = []\n        dataRoute.forEach((objRoute) => {\n            for (let i = 0; i < distance_limit_km_to_stops.length; i++) {\n                const routeStop = objRoute.RouteStops.split(',')\n                for (let j = 0; j < routeStop.length; j++) {\n                    if (routeStop[j] === distance_limit_km_to_stops[i].stop.ID) {\n                        passing_routes_from_start_stop.push({\n                            route: objRoute,\n                            stop_and_distance: distance_limit_km_to_stops[i]\n                        })\n                    }\n                }\n            }\n        })\n\n\n        const date = new Date()\n        const day = date.getDay()\n        const optimal_route_options: Array<optimalRouteType> = []\n\n        const optimal_route: Array<Array<optimalRouteType>> = []\n        passing_routes_from_start_stop.forEach((route_and_distance) => {\n\n            if (route_and_distance.route.Weekdays.split('').indexOf(day.toString())) {\n\n                route_and_distance.route.RouteStops.split(',').forEach((stopID) => {\n\n                    for (let i = 0; i < dataStopping.length; i++) {\n\n                        if (dataStopping[i].ID === stopID) {\n                            const indexStopStart = route_and_distance.route.RouteStops.split(',').indexOf(route_and_distance.stop_and_distance.stop.ID)\n                            const indexStopEnd = route_and_distance.route.RouteStops.split(',').indexOf(dataStopping[i].ID)\n\n                            //search route in the right direction\n                            if (indexStopStart < indexStopEnd) {\n\n                                optimal_route_options.push({\n                                    distance_to_end_point: google.maps.geometry.spherical.computeDistanceBetween(new google.maps.LatLng(handlerMarkers(dataStopping[i])), new google.maps.LatLng(end_point)) * 0.001,\n                                    distance_to_start_point: route_and_distance.stop_and_distance.distance_km_to_stop,\n                                    stop_to_exit: dataStopping[i],\n                                    start_stop: route_and_distance.stop_and_distance.stop,\n                                    route: route_and_distance.route\n                                })\n                            }\n                        }\n                    }\n                    optimal_route_options.sort((a, b) => (a.distance_to_end_point + a.distance_to_start_point) - (b.distance_to_end_point + b.distance_to_start_point))\n                    optimal_route.push(optimal_route_options)\n                })\n            }\n        })\n\n        optimal_route.sort((a, b) => (a[0].distance_to_end_point + a[0].distance_to_start_point) - (b[0].distance_to_end_point + b[0].distance_to_start_point))\n        return optimal_route[0][0]\n    }\n\n\n    const true_route_section = (start: locationsType, end: locationsType, dataStopping: Array<stoppingType>): { points_along_route: Array<locationsType> } => {\n        const optimalRoute: optimalRouteType = search_optimal_route(start, end)\n        const points_along_route = route_building(dataStopping, optimalRoute.route.RouteStops.split(','))\n\n        return {\n            points_along_route: points_along_route.slice(optimalRoute.route.RouteStops.split(',').indexOf(optimalRoute.start_stop.ID),\n                optimalRoute.route.RouteStops.split(',').indexOf(optimalRoute.stop_to_exit.ID.toString()))\n        }\n    }\n\n    const markerOptions = {\n        polylineOptions: {\n            strokeColor: 'red',\n            strokeWeight: 6,\n            strokeOpacity: .6\n        }\n    }\n    const route = true_route_section(start, end, dataStopping)\n    const distance = (route: { points_along_route: Array<locationsType> }) => {\n        const distance_from_last_stop_to_end_point = google.maps.geometry.spherical.computeDistanceBetween(new google.maps.LatLng(route.points_along_route[route.points_along_route.length - 1]),\n            new google.maps.LatLng(end)) * 0.001\n\n\n        let distance_route = 0\n        for (let i = 0; i < route.points_along_route.length; i++) {\n            if (route.points_along_route[i + 1]) {\n                distance_route += google.maps.geometry.spherical.computeDistanceBetween(new google.maps.LatLng(route.points_along_route[i]), new google.maps.LatLng(route.points_along_route[i + 1])) * 0.001\n            }\n        }\n\n        return {distance_from_last_stop_to_end_point, distance_route}\n    }\n\n\n    //===========================================рефакторить==============================================\n    if (distance(route).distance_route > 1) {\n        render_route_walking.push({pointStart: start, pointEnd: route.points_along_route[0]})\n\n        split_and_show_route(route.points_along_route, arrayDirectionsRenderer_for_calcRouteClick, markerOptions, false)\n        const route2 = true_route_section(route.points_along_route[route.points_along_route.length - 1], end, dataStopping)\n\n        if (distance(route2).distance_route > 1) {\n\n            render_route_walking.push({\n                pointStart: route.points_along_route[route.points_along_route.length - 1],\n                pointEnd: route2.points_along_route[0]\n            })\n            split_and_show_route(route2.points_along_route, arrayDirectionsRenderer_for_calcRouteClick2, markerOptions, false)\n\n            render_route_walking.push({\n                pointStart: route2.points_along_route[route2.points_along_route.length - 1],\n                pointEnd: end\n            })\n\n        } else {\n            render_route_walking.push({\n                pointStart: route.points_along_route[route.points_along_route.length - 1],\n                pointEnd: end\n            })\n        }\n    } else {\n        render_route_walking.push({pointStart: start, pointEnd: end})\n    }\n\n    walking_route(render_route_walking)\n\n    //\n    // console.log(distance_from_a_to_b + ' км от А до Б')\n    // console.log(distance(route).distance_route + ' км маршрут')\n    // console.log(distance(route).distance_from_last_stop_to_end_point + ' км от последней отсановки до конечной точки')\n    // console.log(route)\n}\n\n\nconst route_building = (dataStopping: Array<stoppingType>, stoppingRoute: Array<string>) => {\n\n    const dataStopsForRoute: Array<stoppingType> = []\n    dataStopping.forEach((objStopping: stoppingType) => {\n        for (let i = 0; i < stoppingRoute.length; i++) {\n            if (objStopping.ID === stoppingRoute[i]) {\n                dataStopsForRoute.push(objStopping)\n            }\n        }\n    });\n\n//building a route in the right order\n    const index = []\n    const copyStopsDataForRoute = [...dataStopsForRoute]\n    for (let i = 0; i < stoppingRoute.length; i++) {\n        index.push(stoppingRoute.indexOf(dataStopsForRoute[i].ID))\n        copyStopsDataForRoute[index[i]] = dataStopsForRoute[i]\n    }\n    const route: Array<locationsType> = copyStopsDataForRoute.map((objStops: stoppingType) => handlerMarkers(objStops))\n\n    return route\n}\n\n\nfunction split_and_show_route(route: Array<locationsType>, DirectionsRenderer: Array<google.maps.DirectionsRenderer>, markerOptions: google.maps.DirectionsRendererOptions, stopover: boolean) {\n\n    const partsRoute = []\n    const max = 25\n    for (let i = 0; i < route.length; i = i + max) {\n        partsRoute.push(route.slice(i, i + max + 1))\n    }\n\n    for (let i = 0; i < partsRoute.length; i++) {\n        let waypoints = [];\n        for (let j = 1; j < partsRoute[i].length - 1; j++) {\n            waypoints.push({\n                location: new google.maps.LatLng(partsRoute[i][j].lat, partsRoute[i][j].lng),\n                stopover: stopover\n            })\n        }\n\n        const request = {\n            origin: route[0],\n            destination: route[route.length - 1],\n            waypoints: waypoints,\n            travelMode: google.maps.TravelMode.DRIVING\n        }\n\n        DirectionsRenderer.push(new google.maps.DirectionsRenderer())\n        directionsService.route(request, (result: google.maps.DirectionsResult, status: google.maps.DirectionsStatus) => {\n            if (status === 'OK') {\n                DirectionsRenderer[i].setDirections(result)\n                DirectionsRenderer[i].setMap(map)\n                DirectionsRenderer[i].setOptions(markerOptions)\n            }\n        })\n    }\n}\n\n\nconst walking_route = (render_route_walking: Array<{ pointStart: locationsType, pointEnd: locationsType }>) => {\n\n    const markerOptions = {\n        polylineOptions: {\n            strokeColor: 'grey',\n            strokeWeight: 4,\n            strokeOpacity: .6,\n        },\n        suppressMarkers: true\n    }\n\n    for (let i = 0; i < render_route_walking.length; i++) {\n        arrayDirectionsRenderer_for_walking_route.push(new google.maps.DirectionsRenderer())\n\n        const request = {\n            origin: render_route_walking[i].pointStart,\n            destination: render_route_walking[i].pointEnd,\n            travelMode: google.maps.TravelMode.WALKING\n        }\n\n        directionsService.route(request, (result: google.maps.DirectionsResult, status: google.maps.DirectionsStatus) => {\n            if (status === 'OK') {\n                arrayDirectionsRenderer_for_walking_route[i].setDirections(result)\n                arrayDirectionsRenderer_for_walking_route[i].setMap(map)\n                arrayDirectionsRenderer_for_walking_route[i].setOptions(markerOptions)\n            }\n        })\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","C:\\Users\\Anton\\Desktop\\MinskTrans\\googleMap\\src\\Route.tsx",[],["60","61"],"C:\\Users\\Anton\\Desktop\\MinskTrans\\googleMap\\src\\times.ts",["62","63","64","65","66","67","68","69","70","71","72","73"],"export type trips_by_daysType = {\r\n    timeArrivals: Array<Array<number>>,\r\n    days_of_week: Array<number>,\r\n}\r\n\r\nexport type timetableType = {\r\n    routeID: number\r\n    trips_by_days: Array<trips_by_daysType>\r\n}\r\n\r\n\r\nfunction getTimes(encodedSchedule: Array<string>) {\r\n    return encodedSchedule.map(encoded_line => {\r\n        const index = encoded_line.indexOf(\",\");\r\n        const routeID = parseInt(encoded_line.substr(0, index));\r\n        const decoded_data = decodeTimes(encoded_line.substr(index + 1));\r\n\r\n        // const days_of_week_groups = Array.from(new Set(decoded_data.workdays));\r\n\r\n        let trips_by_days: Array<trips_by_daysType> = Array.from(new Set(decoded_data.workdays)).map(function (element) {\r\n            return {\r\n                days_of_week: element.replace('7', '0').split('').map((item: string) => parseInt(item)).sort(),\r\n                tmp_days_of_week_str: element,\r\n                timeArrivals: []\r\n            };\r\n        });\r\n        const jump_step = decoded_data.workdays.length;\r\n        for (let j = 0, m = decoded_data.times.length / jump_step; j < m; j++) {\r\n            let myMap: any = new Map();\r\n            for (let i = 0, str_days_of_week = decoded_data.workdays[0]; i < jump_step; str_days_of_week = decoded_data.workdays[++i]) {\r\n                let tmp = myMap.get(str_days_of_week);\r\n                if (!tmp) {\r\n                    tmp = {\r\n                        str_days_of_week,\r\n                        timeArrivals: []\r\n                    };\r\n                    myMap.set(str_days_of_week, tmp);\r\n                }\r\n                tmp.timeArrivals.push(decoded_data.times[i + j * jump_step]);\r\n            }\r\n            for (let [key, value] of myMap) {\r\n                //@ts-ignore\r\n                trips_by_days.find((item) => item.tmp_days_of_week_str === key).timeArrivals.push(value.timeArrivals);\r\n            }\r\n        }\r\n\r\n        trips_by_days.map((item:any) => delete item.tmp_days_of_week_str);\r\n\r\n        return {\r\n            routeID: routeID,\r\n            trips_by_days\r\n        };\r\n    });\r\n}\r\n\r\n\r\nfunction decodeTimes(encoded_data: any) {\r\n\r\n    var timetable = []; // atkoduoti laikai\r\n    var weekdays = []; // atkoduotos savaites dienos\r\n    var valid_from = []; // isigaliojimo datos\r\n    var valid_to = []; // pasibaigimo datos\r\n\r\n    var w; // laiku lenteles plotis, gausim atkoduodami reisu pradzias\r\n    var h; // laiku lenteles aukstis;\r\n\r\n    var times = encoded_data.split(\",\");\r\n    var i, prev_t;\r\n    var i_max = times.length;\r\n\r\n    var zero_ground = [], plus = \"+\", minus = \"-\";\r\n\r\n    for (i = -1, w = 0, h = 0, prev_t = 0; ++i < i_max;) { // atkoduojam reisu pradzios laikus\r\n        var t = times[i];\r\n\r\n        if (t === \"\") { //pasibaige reisu pradzios\r\n            break;\r\n        }\r\n\r\n        var tag = t.charAt(0);\r\n        if (tag === plus || (tag === minus && t.charAt(1) === \"0\")) {\r\n            zero_ground[i] = \"1\";\r\n        }\r\n\r\n        prev_t += +(t);\r\n        timetable[w++] = prev_t;\r\n    }\r\n\r\n    for (var j = zero_ground.length; --j >= 0;) {\r\n        if (!zero_ground[j]) {\r\n            zero_ground[j] = \"0\";\r\n        }\r\n    }\r\n\r\n    // atkoduojame isigaliojimo datas\r\n    for (var j = 0; ++i < i_max;) {\r\n        var day = +(times[i]); // skaitom isigaliojimo data\r\n        var k = times[++i]; // kiek kartu pakartoti\r\n\r\n        if (k === \"\") { // pabaiga\r\n            k = w - j; // irasysim reiksme i likusius elementus\r\n            i_max = 0; // kad iseitu is atkodavimo ciklo\r\n        } else {\r\n            k = +(k);\r\n        }\r\n\r\n        while (k-- > 0) {\r\n            valid_from[j++] = day;\r\n        }\r\n    }\r\n\r\n    // atkoduojame pasibaigimo datas\r\n    --i;\r\n\r\n    for (var j = 0, i_max = times.length; ++i < i_max;) {\r\n        var day = +(times[i]); // pasibaigimo data\r\n        var k = times[++i]; // kiek kartu pakartoti\r\n\r\n        if (k === \"\") { // pabaiga\r\n            k = w - j; // irasysim reiksme i likusius elementus\r\n            i_max = 0; // kad iseitu is atkodavimo ciklo\r\n        } else {\r\n            k = +(k);\r\n        }\r\n\r\n        while (k-- > 0) {\r\n            valid_to[j++] = day;\r\n        }\r\n    }\r\n\r\n    // atkoduojame savaites dienas\r\n    --i;\r\n\r\n    for (var j = 0, i_max = times.length; ++i < i_max;) {\r\n        var weekday = times[i]; // skaitom savaites dienas\r\n        var k = times[++i]; // kiek kartu pakartoti\r\n\r\n        if (k === \"\") { // pabaiga\r\n            k = w - j; // irasysim savaites dienas i likusius elementus\r\n            i_max = 0; // kad iseitu is savaites dienu atkodavimo cikla\r\n        } else {\r\n            k = +(k);\r\n        }\r\n\r\n        while (k-- > 0) {\r\n            weekdays[j++] = weekday;\r\n        }\r\n    }\r\n\r\n    // atkoduojame vaziavimo laikus iki sekancios stoteles kiekviename reise\r\n    --i;\r\n    h = 1;\r\n\r\n    for (var j = w, w_left = w, dt = 5, i_max = times.length; ++i < i_max;) {\r\n        dt += +(times[i]) - 5; // vaziavimo laikas nuo ankstesnes stoteles\r\n        var k = times[++i]; // kiek reisu tinka tas pats vaziavimo laikas\r\n\r\n        if (k !== \"\") { // ne visiems likusiems reisams\r\n            k = +(k);\r\n            w_left -= k; // kiek liko neuzpildytu lenteles elementu eiluteje\r\n        } else {\r\n            k = w_left; // vaziavimo laikas tinka visiems likusiems reisams\r\n            w_left = 0;\r\n        }\r\n\r\n        while (k-- > 0) {\r\n            timetable[j] = dt + timetable[j - w]; // jei lentele vienmatis masyvas\r\n            ++j;\r\n        }\r\n\r\n        if (w_left <= 0) {\r\n            w_left = w; // vel nustatome, kad neuzpildytas visas lenteles plotis sekancioje eiluteje\r\n            dt = 5; // pradinis laiko postumis +5 sekanciai eilutei\r\n            ++h;\r\n        }\r\n    }\r\n\r\n    const  final_data = {\r\n        workdays: weekdays,\r\n        times: timetable,\r\n        tag: zero_ground.join(\"\"),\r\n        valid_from: valid_from,\r\n        valid_to: valid_to\r\n    };\r\n\r\n    return final_data;\r\n}\r\n\r\n\r\nexport default getTimes;\r\n\r\n","C:\\Users\\Anton\\Desktop\\MinskTrans\\googleMap\\src\\InformationTable.tsx",[],"C:\\Users\\Anton\\Desktop\\MinskTrans\\googleMap\\src\\Timetable.tsx",["74","75"],"import {v1} from \"uuid\";\r\nimport React from 'react';\r\nimport {tableType} from \"./InformationTable\";\r\n\r\ntype timetableType = {\r\n    table: tableType\r\n}\r\n\r\nfunction Timetable(props: timetableType) {\r\n    let hour: number\r\n    const daysOfWeek = [' Вс ', ' Пн ', ' Вт ', ' Ср ', ' Чт ', ' Пт ', ' Сб ']\r\n\r\n\r\n    const handlerTimes = (time: number) => {\r\n        let hour = Math.floor(time / 60)\r\n        let minute = Math.round(((time / 60) - hour) * 60)\r\n        return {hour: hour >= 24 ? hour - 24 : hour, minute: minute.toString().length < 2 ? '0' + minute : minute}\r\n    }\r\n\r\n    return <table>\r\n        <thead>{}</thead>\r\n        <tbody className={'table'}>{\r\n            props.table?.map((objTimetable) => {\r\n                return<tr className={'table'} key={v1()}><td key={v1()} className={'day_timetable'}>{objTimetable.days_of_week.map((day) =>{\r\n                    return <span className={'day' + day.toString()} key={v1()}>{daysOfWeek[day]}</span>\r\n                })}</td>\r\n                <td key={v1()}>{objTimetable.time.map((timeHour) => {\r\n                    if (hour !== handlerTimes(timeHour).hour || objTimetable.time.length < 2) {\r\n                        hour = handlerTimes(timeHour).hour\r\n                        return <table key={v1()}>\r\n                            <tbody>\r\n                            <tr key={v1()}>\r\n                                <td key={v1()} className={'hour'}>{hour}</td>\r\n                                {objTimetable.time.map((timeMinute) => {\r\n                                    if (hour === handlerTimes(timeMinute).hour) {\r\n                                        return <td key={v1()} className={'minute'}>{handlerTimes(timeMinute).minute}</td>\r\n                                    }\r\n                                })}\r\n                            </tr>\r\n                            </tbody>\r\n                        </table>\r\n                    }\r\n                })\r\n                }\r\n                </td></tr>\r\n            })\r\n        }\r\n        </tbody>\r\n\r\n    </table>\r\n}\r\n\r\nexport default Timetable","C:\\Users\\Anton\\Desktop\\MinskTrans\\googleMap\\src\\SelectedStop.tsx",[],{"ruleId":"76","replacedBy":"77"},{"ruleId":"78","replacedBy":"79"},{"ruleId":"80","severity":1,"message":"81","line":83,"column":57,"nodeType":"82","messageId":"83","endLine":83,"endColumn":58},{"ruleId":"80","severity":1,"message":"81","line":83,"column":71,"nodeType":"82","messageId":"83","endLine":83,"endColumn":72},{"ruleId":"80","severity":1,"message":"81","line":83,"column":124,"nodeType":"82","messageId":"83","endLine":83,"endColumn":125},{"ruleId":"80","severity":1,"message":"81","line":84,"column":16,"nodeType":"82","messageId":"83","endLine":84,"endColumn":17},{"ruleId":"80","severity":1,"message":"81","line":84,"column":41,"nodeType":"82","messageId":"83","endLine":84,"endColumn":42},{"ruleId":"80","severity":1,"message":"81","line":84,"column":51,"nodeType":"82","messageId":"83","endLine":84,"endColumn":52},{"ruleId":"84","severity":1,"message":"85","line":123,"column":17,"nodeType":"86","messageId":"87","endLine":123,"endColumn":37},{"ruleId":"88","severity":1,"message":"89","line":134,"column":33,"nodeType":"90","messageId":"91","endLine":134,"endColumn":74},{"ruleId":"88","severity":1,"message":"89","line":147,"column":33,"nodeType":"90","messageId":"91","endLine":147,"endColumn":74},{"ruleId":"92","severity":1,"message":"93","line":152,"column":25,"nodeType":"94","messageId":"95","endLine":152,"endColumn":27},{"ruleId":"88","severity":1,"message":"89","line":210,"column":29,"nodeType":"90","messageId":"91","endLine":210,"endColumn":70},{"ruleId":"92","severity":1,"message":"96","line":260,"column":61,"nodeType":"94","messageId":"97","endLine":260,"endColumn":63},{"ruleId":"98","severity":1,"message":"99","line":277,"column":70,"nodeType":"94","messageId":"100","endLine":277,"endColumn":154},{"ruleId":"98","severity":1,"message":"101","line":462,"column":42,"nodeType":"94","messageId":"100","endLine":468,"endColumn":10},{"ruleId":"98","severity":1,"message":"101","line":493,"column":42,"nodeType":"94","messageId":"100","endLine":499,"endColumn":10},{"ruleId":"76","replacedBy":"102"},{"ruleId":"78","replacedBy":"103"},{"ruleId":"104","severity":1,"message":"105","line":96,"column":14,"nodeType":"86","messageId":"106","endLine":96,"endColumn":15},{"ruleId":"104","severity":1,"message":"105","line":115,"column":14,"nodeType":"86","messageId":"106","endLine":115,"endColumn":15},{"ruleId":"104","severity":1,"message":"107","line":115,"column":21,"nodeType":"86","messageId":"106","endLine":115,"endColumn":26},{"ruleId":"104","severity":1,"message":"108","line":116,"column":13,"nodeType":"86","messageId":"106","endLine":116,"endColumn":16},{"ruleId":"104","severity":1,"message":"109","line":117,"column":13,"nodeType":"86","messageId":"106","endLine":117,"endColumn":14},{"ruleId":"104","severity":1,"message":"105","line":134,"column":14,"nodeType":"86","messageId":"106","endLine":134,"endColumn":15},{"ruleId":"104","severity":1,"message":"107","line":134,"column":21,"nodeType":"86","messageId":"106","endLine":134,"endColumn":26},{"ruleId":"104","severity":1,"message":"109","line":136,"column":13,"nodeType":"86","messageId":"106","endLine":136,"endColumn":14},{"ruleId":"104","severity":1,"message":"105","line":154,"column":14,"nodeType":"86","messageId":"106","endLine":154,"endColumn":15},{"ruleId":"104","severity":1,"message":"107","line":154,"column":41,"nodeType":"86","messageId":"106","endLine":154,"endColumn":46},{"ruleId":"104","severity":1,"message":"109","line":156,"column":13,"nodeType":"86","messageId":"106","endLine":156,"endColumn":14},{"ruleId":"84","severity":1,"message":"110","line":174,"column":15,"nodeType":"86","messageId":"87","endLine":174,"endColumn":16},{"ruleId":"92","severity":1,"message":"111","line":27,"column":66,"nodeType":"94","messageId":"97","endLine":27,"endColumn":68},{"ruleId":"92","severity":1,"message":"111","line":34,"column":69,"nodeType":"94","messageId":"97","endLine":34,"endColumn":71},"no-native-reassign",["112"],"no-negated-in-lhs",["113"],"no-useless-concat","Unexpected string concatenation of literals.","BinaryExpression","unexpectedConcat","@typescript-eslint/no-unused-vars","'distance_from_a_to_b' is assigned a value but never used.","Identifier","unusedVar","@typescript-eslint/consistent-type-assertions","Use 'as google.maps.Size' instead of '<google.maps.Size>'.","TSTypeAssertion","as","array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","Array.prototype.filter() expects a value to be returned at the end of arrow function.","expectedAtEnd","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'search_radius_km'.","unsafeRefs","Function declared in a loop contains unsafe references to variable(s) 'google', 'google', 'map'.",["112"],["113"],"@typescript-eslint/no-redeclare","'j' is already defined.","redeclared","'i_max' is already defined.","'day' is already defined.","'k' is already defined.","'h' is assigned a value but never used.","Array.prototype.map() expects a value to be returned at the end of arrow function.","no-global-assign","no-unsafe-negation"]